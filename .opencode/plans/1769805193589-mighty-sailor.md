# Plan: Create Schedule Primitive

## Summary

Create the Schedule primitive as defined in docs/primitives.md:

- **Schedule**: cadence, triggers, time windows, run policy
- Triggers Workflow instance or Questioner
- Generates Notification on triggers

## Design Decisions

### ID Pattern

- ScheduleId prefix: `sch_` (following convention: tag*, qst*, cmt*, fwk*, ctr*, doc*)

### Schema Fields

**Schedule Core Fields:**

1. **id**: ScheduleId
2. **name**: string (human-readable name)
3. **description**: string | null
4. **cadence**: string (cron expression like "0 0 \* \* \*")
5. **timeZone**: string (IANA timezone like "America/New_York")
6. **startDate**: DateTimeUtc | null (when schedule becomes active)
7. **endDate**: DateTimeUtc | null (when schedule expires)
8. **triggerType**: "workflow_instance" | "questioner" | "notification"
9. **triggerConfig**: JSON object with trigger-specific config
   - For workflow_instance: workflowTemplateId, initialState, etc.
   - For questioner: questionerId, entityId, entityType, etc.
   - For notification: message template, recipients, etc.
10. **runPolicy**: object with:
    - maxRetries: number (default 3)
    - retryDelay: number (minutes, default 5)
    - concurrency: "allow" | "skip" | "queue" (default "skip")
    - timeout: number (minutes, default 30)
11. **enabled**: boolean (default true)
12. **lastRunAt**: DateTimeUtc | null
13. **nextRunAt**: DateTimeUtc | null
14. **runCount**: number (default 0)
15. **failureCount**: number (default 0)

### File Structure

```
packages/domain/primitives/
  schedule.ts          # Domain model, schemas, factories

packages/core/
  migrations/
    0005_schedule.ts   # Database migration
  src/schedule/
    service.ts         # Business logic layer
    contract.ts        # RPC contract definitions
    handler.ts         # RPC handler implementation
    repository.ts      # Data access layer

packages/domain/src/index.ts  # Add Schedule export
```

### Database Schema

```sql
CREATE TABLE schedule (
  id VARCHAR(255) PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  cadence VARCHAR(255) NOT NULL,  -- cron expression
  time_zone VARCHAR(255) NOT NULL DEFAULT 'UTC',
  start_date TIMESTAMPTZ,
  end_date TIMESTAMPTZ,
  trigger_type VARCHAR(50) NOT NULL,
  trigger_config JSONB NOT NULL DEFAULT '{}',
  run_policy JSONB NOT NULL DEFAULT '{"maxRetries":3,"retryDelay":5,"concurrency":"skip","timeout":30}',
  enabled BOOLEAN NOT NULL DEFAULT true,
  last_run_at TIMESTAMPTZ,
  next_run_at TIMESTAMPTZ,
  run_count INTEGER NOT NULL DEFAULT 0,
  failure_count INTEGER NOT NULL DEFAULT 0,
  -- Base fields
  org_id VARCHAR(255) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at TIMESTAMPTZ,
  created_by VARCHAR(255) NOT NULL DEFAULT 'system',
  updated_by VARCHAR(255) NOT NULL DEFAULT 'system',
  deleted_by VARCHAR(255),
  hash VARCHAR(255) NOT NULL DEFAULT 'system'
);

CREATE INDEX schedule_org_idx ON schedule(org_id);
CREATE INDEX schedule_enabled_next_run_idx ON schedule(enabled, next_run_at);
CREATE INDEX schedule_trigger_type_idx ON schedule(trigger_type);
```

### Domain Model (schedule.ts)

Following the pattern from tag.ts and questioner.ts:

1. **Branded ID types**:
   - `ScheduleId` with prefix `sch_`

2. **Schema types**:
   - `Cadence`: cron expression string (validated)
   - `TimeZone`: IANA timezone string
   - `TriggerType`: union literal type
   - `TriggerConfig`: union of different config schemas
   - `RunPolicy`: struct with retry/concurrency settings

3. **Main Schedule class** extending Base.Base

4. **Create/Update schemas**:
   - `CreateSchedule`: input for creating
   - `UpdateSchedule`: input for updating

5. **Factory functions**:
   - `make`: create new schedule
   - `update`: update existing schedule
   - `remove`: soft delete
   - `calculateNextRun`: compute next run time from cadence
   - `recordRun`: update lastRunAt, nextRunAt, runCount
   - `recordFailure`: update failureCount
   - `enable/disable`: toggle enabled flag

6. **Errors**:
   - `ScheduleNotFoundError`
   - `InvalidCadenceError` (for invalid cron)
   - `InvalidTimeZoneError`

### Service Layer (service.ts)

Following patterns from tag/service.ts:

1. CRUD operations (create, getById, list, update, delete)
2. Business logic:
   - `listReadyToRun`: find schedules where nextRunAt <= now AND enabled = true
   - `executeSchedule`: trigger the configured action
   - `calculateNextRuns`: batch update nextRunAt for all schedules

### RPC Contract (contract.ts)

Following patterns from existing contracts:

Endpoints:

- `schedule.create`: Create new schedule
- `schedule.getById`: Get single schedule
- `schedule.list`: List schedules with filters
- `schedule.update`: Update schedule
- `schedule.delete`: Delete schedule
- `schedule.listReadyToRun`: Admin endpoint for scheduler daemon

### Migration (0005_schedule.ts)

Following pattern from 0003_tag.ts:

- CREATE TABLE schedule with all columns
- CREATE INDEX statements for query patterns
- Use TIMESTAMPTZ for all dates
- Use JSONB for trigger_config and run_policy

### Integration Points

1. **Domain exports**: Add `export * as Schedule from "../primitives/schedule"` to packages/domain/src/index.ts
2. **Core integration**: Register ScheduleService in core service layer
3. **Cron parsing**: Need to add a cron parser dependency (e.g., `cron-parser` or implement simple parser)

### Cron Expression Validation

Support standard cron format: `* * * * *` (minute hour day month weekday)

- minute: 0-59
- hour: 0-23
- day: 1-31
- month: 1-12
- weekday: 0-6 (0 = Sunday)

Or use ISO 8601 recurring intervals as alternative.

### Time Zone Support

Use IANA timezone names (e.g., "America/New_York", "Europe/London", "UTC")
Store as string, validate on input.

### Trigger Types

1. **workflow_instance**:

   ```typescript
   {
     workflowTemplateId: string,
     initialState?: object,
     assignedTo?: string
   }
   ```

2. **questioner**:

   ```typescript
   {
     questionerId: string,
     entityId: string,
     entityType: string
   }
   ```

3. **notification**:
   ```typescript
   {
     templateId: string,
     recipientIds: string[],
     channel: "email" | "slack" | "in_app"
   }
   ```

## Implementation Steps

### Phase 1: Domain Layer

- [ ] Create packages/domain/primitives/schedule.ts
  - [ ] Define ScheduleId branded type
  - [ ] Define Cadence, TimeZone, TriggerType schemas
  - [ ] Define TriggerConfig union type
  - [ ] Define RunPolicy schema
  - [ ] Create Schedule class extending Base
  - [ ] Create CreateSchedule, UpdateSchedule schemas
  - [ ] Implement make, update, remove factory functions
  - [ ] Implement calculateNextRun function
  - [ ] Implement recordRun, recordFailure functions
  - [ ] Implement enable/disable functions
  - [ ] Define ScheduleNotFoundError
- [ ] Update packages/domain/src/index.ts to export Schedule
- [ ] Run typecheck: `bun run tsc --noEmit` in packages/domain

### Phase 2: Migration

- [ ] Create packages/core/migrations/0005_schedule.ts
  - [ ] CREATE TABLE schedule with all columns
  - [ ] CREATE INDEX statements
- [ ] Test migration runs successfully

### Phase 3: Service Layer

- [ ] Create packages/core/src/schedule/repository.ts
  - [ ] CRUD operations
  - [ ] listReadyToRun query
- [ ] Create packages/core/src/schedule/service.ts
  - [ ] CRUD service methods
  - [ ] listReadyToRun business method
- [ ] Create packages/core/src/schedule/contract.ts
  - [ ] RPC endpoint definitions
- [ ] Create packages/core/src/schedule/handler.ts
  - [ ] RPC handler implementation
- [ ] Run typecheck: `bun run tsc --noEmit` in packages/core

### Phase 4: Integration

- [ ] Register Schedule handler in packages/core/src/rpc.ts
- [ ] Export Schedule from appropriate index files

### Phase 5: Verification

- [ ] Run all type checks pass
- [ ] Verify migration applies cleanly
- [ ] Test basic CRUD operations work

## Dependencies to Add

None required immediately - use existing dependencies:

- `effect` for Effect-TS
- `@effect/sql` for database
- `ulid` for ID generation

May need to add later for cron parsing:

- `cron-parser` or similar

## Open Questions

1. **Cron library**: Should we use an existing npm package like `cron-parser` or `node-cron` for parsing/validation, or implement simple parsing internally?
2. **Scheduler daemon**: Is there a separate scheduler process that calls `listReadyToRun`, or should schedules be triggered differently?
3. **Trigger execution**: Should the schedule service directly trigger workflows/questioners, or publish events for other services to consume?
4. **Multiple triggers**: Should a schedule support multiple triggers, or one trigger per schedule?
5. **Run history**: Do we need a separate `schedule_run` table to track individual run history, or is lastRunAt/nextRunAt sufficient?
